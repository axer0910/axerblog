---
title: 剑指Offer 66道算法题整理（持续补充中...）
tag: 算法
date: 2020-06-03
updated: 2020-06-03
---

1.  #### 二维数组中的查找
https://leetcode.com/problems/search-a-2d-matrix-ii/

* 思路：一定要从右上角开始进行查找，根据题意矩阵的横向和纵向都是递增序列，如果从矩阵左上角位置开始查找，不容易对需要进行搜索的数确定范围（横向纵向都是递增序列），从右上角搜索的话，向左是递减，向下是递增，这样只需要目标数比当前数大就向下搜索，目标数比当前数小就向左搜索（类似于二分，不断缩小范围）。

2. #### 替换空格
  > 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20
Are%20Happy

* 正则替换就ok了（str.replace('/\s/g', '%20')）或者for循环遍历直接替换空格

3. #### 逆序输出链表：
* 输出链表每个节点的值：从头节点遍历链表，push到一个临时数组，完成遍历后再一个个从数组中pop值即可。
* 反转链表：https://leetcode.com/problems/reverse-linked-list/
迭代法思路：
```javascript
var reverseList = function(head) {
  if (!head || !head.next) return head;
  let newHead = null; // newHead在每次迭代中都指向head，同时更新next，最后实现翻转
  while (head) {
    const temp = head; // 临时保存头节点信息
    head = head.next; // 头指针指向先下一个节点
    temp.next = newHead; // 翻转后的节点，在第一轮temp此时是作为反转后链表的最后一个节点（next指向null）
    newHead = temp; // 在第一轮更新的newHead指向最后一个节点，后续newHead不断向前指向头节点
  }
  return newHead;
};
```
4. #### 重建二叉树
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

* 思路：前序遍历中，每一个节点都对应的是二叉树根节点。在中序遍历中，所有节点都是以左-根-右的顺序进行遍历。根据这个特性，先确定前序遍历中每个元素在后序遍历中的位置，确定了在后序遍历中的位置以后，所有在后序遍历中左边部分是重建后二叉树的左子树，右边部分是右子树。所以只需要用一个函数，接受两个后序遍历左右位置的参数，确定每次构建二叉树寻找的范围。找到根节点位置后将此位置作为中枢分别对左半部分和右半部分递归进行构建二叉树即可。

5. #### 用两个栈实现队列
 https://leetcode.com/problems/implement-queue-using-stacks/submissions/

思路：题目要求用两个栈来实现队列操作。思路是添加队列内容时在第一个栈里进行push，当需要取队列内容的时候，将队列所有内容pop到第二个栈（栈先进后出的特点，pop到第二个栈所有元素顺序正好变成先进先出），再进行pop即可取出一个队列内容。

6. #### 旋转数组的最小数字
> 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的
最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大
小为 0，请返回 0。

思路：

（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相
邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。

（2）二分法

leetcode没找到对应的题目，暂时先记录一下思路

7. #### 斐波那契数列
输入斐波那契数列第n项返回斐波那契数列总和。求和的过程就是斐波那契数列当前n项的和 =（n-1）项的和加上（n-2）项和。用递归即可。不用递归的话，用两个变量分别记录n-1的和和n-2的和，每次轮询进行相加。

https://leetcode.com/problems/fibonacci-number/

<!-- more -->

8. #### 跳台阶
9. #### 变态跳台阶

https://leetcode.com/problems/climbing-stairs/ 
解法是动态规划，关键思路是要得出当前台阶数n所对应的方法数量，由于一次可以跳一个台阶或者两个台阶，所以当前台阶数n对应的方法数量 = n-1个台阶的方法数加上n -2个台阶方法数。（这个推导过程可以理解为n-1对应的所有方法中每个方法都可以再跳一层达到当前状态，n-2同理），变态跳台阶（可以一次跳n个台阶）公式则变为n = (n - 1) + (n - 2) + ... + (n - n)。
关键思路：获取当前状态怎么由上一个状态+能达到这个状态的关系

10. #### 矩形覆盖
> 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

思路：也是斐波那契数列（动态规划）的应用。当只有一个2 * 1的矩形，只有一种方法，即使用2 * 1的矩形去覆盖，当有一个2 * 2的矩形，可以用两个2*1的矩形横向覆盖也可以纵向覆盖，所以有两种方法。当有一个2 * 3的矩形，可以有（形成2 * 2组成矩形的方法+用一个矩形去覆盖）的数量+（形成2 * 1组成矩形的方法+用一个矩形去覆盖）的数量。 所以推导关系就是`f(n-1)+f(n-2)`。

11. #### 二进制中 1 的个数
> 题目：输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。
> 举例：二进制00000000000000000000000000001011中，共有3个1，11111111111111111111111111111101中有31个1

https://leetcode.com/problems/number-of-1-bits/

一个不为0的二进制数，一定在最右边存在以为1，拿1100为例子，为了取得二进制中1的个数，可以先减掉1，1100就变成了1011，这样除了最高位其余位数都退了1位。利用这个特点将减1后的数字和没减之前的数字进行与运算，1100&1011=1000。如果与运算结果不为1，那意味着最高位还存在1。此时再讲1011减1，重复与运算的过程，只要最后与运算结果不为0，数量就递增，最后就可以统计出1的个数。

12. #### 数值的整数次方
> 题目：给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。 

https://leetcode.com/problems/powx-n/

最直接的办法就是写个循环指数是多少base就乘以几次，但是在这道题中指数最大可以取到32位有符号整数。这意味着当指数很大的时候直接相乘会超时，必须想办法节省时间。分析直接实现pow的过程可以发现，2^3次方就是2 * 2 * 2 乘以三次，当2^4次方的时候，就是2 * 2 * 2 * 2，如果指数是2的倍数，只需要乘以指数/2次，将折半后的结果再相乘，这样时间就可以少一半。

比较简洁的递归代码
```javascript
var myPow = function(x, n) {
  if (n == 0) return 1;
  let half = myPow(x, parseInt(n / 2));
  if (n % 2 == 0) return half * half;
  if (n > 0) return half * half * x;
  return half * half / x;
};
```
* 每次递归时，指数取余，如果余数是0（2的倍数），将折半的结果相乘
* 如果不是2的倍数，在折半相乘的基础上再乘以一个基数x
* 如果n小于0，在折半相乘的基础上除以x（如果输入是2^-1，那么return就是1 * 1 / 2 即 0.5），其他的负数重复一样的递归过程（指数取余是0直接折半相乘，不除以x）

13. #### 调整数组顺序使奇数位于偶数前面

> 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/

解法：使用两个指针，左指针指向偶数元素，右指针指向奇数元素。当不满足这个条件的时候，两个指正分别向后和向前移动，直到满足条件时两个指针上的元素进行互换。这样的好处是不用额外空间。但是如果题目要求奇数和奇数，偶数和偶数之间的相对位置不变时，就不能用这个方法了。为了保持顺序的稳定，可以另外建立两个个辅助数组，分别存放偶数元素和奇数元素，最后将辅助数组进行拼接返回即可。时间和空间复杂度均为O(n)。

14. #### 链表中倒数第 k 个节点
> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

解法：遇到这种链表符合某种条件的第k个节点问题，可以考虑将链表进行一些相减的操作。这道题要求出倒数第k个节点，可以用两个节点，先让一个结点先走k-1步，这样与另外一个节点获取了和倒数第k个节点一样的距离差，此时两个节点同时向后移动，当后面一个节点指向最后一个节点时，前面的一个节点即为倒数第k个节点。

15. #### 反转链表

做第三题的时候把反转链表也写了下，见第三题思路。

16. #### 合并两个排序的链表

> 题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

解法：由于是单调递增的两个链表，建立两个指针分别指向两个链表，首先取较小元素作为头结点，然后当两个指针都没有指向末尾的时候，哪个指正对应的指小取哪个，然后链表指针向下。当然也可以用递归的方法实现。

17. #### 树的子结构

> 输入两棵二叉树 A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）

解法：如果B是A的子结构，必然在A中间包含B的根节点，先用DFS的方法递归遍历A树找到与B根节点相同的元素，再讲两个树按照相同的方法继续遍历，判断是不是相同。

18. #### 二叉树的镜像
> 操作给定的二叉树，将其变换为源二叉树的镜像。

解法：递归的解法只需要将当前节点的左右节点互换即可。如果不用递归，可以实现层次遍历，先将左右节点入队，再出队左节点，交换他的子节点，并将子节点入队（如果不为null）。当队列不为空时，重复这个过程即可完成。也可以使用先序遍历，建立一个栈，将根节点入栈，当栈不为空时进行出栈操作，并且交换出栈元素的子节点。当子节点不为null时，再进行入栈，之后一样的出栈操作就可以完成交换。

19. #### 顺时针打印矩阵

https://leetcode.com/problems/spiral-matrix/

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
例如，如果输入如下矩阵： 
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

解法：顺时针打印矩阵的时候，他的范围一定是限制在左上顶点和右下顶点之中。确定了左上顶点和右下顶点，就可以通过for循环依次将四条边打印出来。然后两个顶点两个坐标分别-1和+1向中心推进，再按顺序打印值即可。需要注意的是，如果两个点在矩阵同一行或同一列上面，则需要直接返回，不然会重复输出同一行或同一列矩阵元素。

20. #### 定义一个栈，实现 min 函数
> 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/

解法：建立两个栈，一个存储元素，一个辅助最小元素栈，当当前入栈的元素比最小元素的栈顶元素还要小时，在最小元素栈入栈一个最小元素。取最小元素就取最小元素辅助栈的栈顶。当出栈元素的时候，如果最小元素栈的栈顶为当前出栈元素则一同出栈。取最小值只需要取辅助栈栈顶即可。

21. #### 栈的压入弹出

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如
序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序
列的弹出序列。（注意：这两个序列的长度是相等的）

根据栈的先进后出特点，如果1,2,3,4,5全部按照顺序进行入栈，那么出栈的顺序为5,4,3,2,1。入一个再出一个为1,2,3,4,5
根据这个特点，先将测试的序列与正常出栈的序列进行对比，如果当前指针两边的数字不一样，则跳过继续，否则将元素推入一个辅助栈当中。完成之后先将辅助栈出栈与原栈顺序对比，再将剩余的元素按倒序和原栈顺序对比是否一致。

22. #### 从上往下打印二叉树

> 从上往下打印出二叉树的每个节点，同层节点从左至右打印。

https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/

解法：就是层次遍历，先建立一个队列，将根节点入队，随后出队根节点，再加根节点的左右子节点入队。当队列长度不为0重复这个过程。

23. #### 二叉搜索树的后序遍历

> 输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出 Yes，否则输出 No。假设输入的数组的任意两
个数字都互不相同。

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/

根据后序遍历的特点（先左节点后右节点再父（根）节点的顺序），以及二叉搜索树的特点（左子节点都比根节点小，右子节点都比根节点大），以数组倒数第一个数字为根节点，数组可以被分割为两部分，一部分所有的数字都比根节点的数字大，另一部分都比根节点的数字小。根据这个特点，不断递归分割数组判断即可。

24. #### 二叉树中和为某一值路径

> 输入一棵二叉树和一个整数，打印出二叉树中节点值的和为输入整数的所有路径。从树的根节点开始往下一直到叶节点所经过的节点形成一条路径。

https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/

使用DFS深度遍历整个数，如果**叶子**节点上所有路径的和和sum相同，那么就将这个路径push到结果数组中，注意是要叶子节点上的路径，所以并不是遍历到某个节点的和与目标求和相同就返回。

25. ####  复杂链表的复制

> 输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为
复制后复杂链表的 head。（注意，输出结果中请不要返回参数中的节点引用，否则判题程序会直接返回空）

https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof/

第一个方法是维护一个Map，每遍历一个链表节点时，拷贝一个节点自身，并添加一个键值对，原链表节点作为key，拷贝的节点作为value。当完成遍历的时候，再遍历一遍原链表，通过查询Map来获取原节点对应的拷贝节点，以及设置拷贝节点的next的值和random的值。

第二个方法是每遍历一个链表节点时，多设置一个属性copy到节点自身上，并且设置copy的属性为节点自身的拷贝。当完成遍历的时候，再遍历一遍原链表，设置copy属性上拷贝节点的next以及random。此时的next以及random对应的拷贝的节点都可以通过原节点上的next以及random获取。相对于第一种方法，节省了Map的额外空间。

26. ####  二叉搜索树与双向链表

> 输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/

根据二叉搜索树的性质，如果需要按排序的顺序生成链表，必然要按照中序遍历的顺序进行遍历，这样才能得到排序的节点顺序。题目中要求不建立新节点，那么就需要按顺序，变遍历二叉树边改变每个节点的指向。题目中要求树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。在遍历的过程中，需要一个pre来记录前驱节点，每次遍历到节点的父节点时，将父节点前驱（left）指向pre，同时修改pre的后继（right）指向父节点。

27. ####  字符串的排列

> 输入一个字符串，按字典序打印出该字符串中字符的所有排列。例如输入字符串 abc，则打印出由字符 a,b,c 所能排列出来的所有
字符串 abc,acb,bac,bca,cab 和 cba。输入描述：输入一个字符串，长度不超过 9（可能有字符重复），字符只包括大小写字母。

https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

要求出排列，可以求出字符串在当前处理长度下所有排列的组合，方法为当前处理长度下头和尾字母以递归的方式进行交换。如abc，处理长度为3，将a和c调换得到cba，在cba这个长度下继续处理长度为2的调换过程，即调换cb和ba得到bca和cab。在cba这轮递归处理完成后，在abc中以长度为2交换ab和bc，得到bac和acb。长度为1无需交换，这样就完成了排列的过程。

28. #### 数组中出现次数超过一半的数字

> 数组中有一个数字出现的次数超过数组长度的一半。请找出这个数字。例如输入一个长度为 9 的数组{1,2,3,2,2,2,5,4,2}。由于数
字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。

https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/

* 最简单方法就是将数组进行排序，中位数即为超过一半的数字。这种方法速度取决于排序采用的方法，所以最快也需要O(nlogn)的复杂度。
* 由于可以通过排序直接解决这个问题，其实不需要将所有数字进行排序。在快排算法中，每一轮partition过程中，最后返回的index即为在整个数组中排序好的位置。所以只要partition过程中返回的index为中位数，那么这个元素就是超过一半的数字。此时复杂度可以降低为O(n)
* 还可以使用摩尔投票法，这个方法不需要O(n)的空间，只需要两个变量，一个是当前的数字，一个是当前数字出现的次数。下一个数字为当前出现的数字时，如果下一个数字与之前保存的数字相同，则次数加 1，如果不同，则次数减 1，如果次数为 0，则需要保存下一个数字，并把次数设定为 1。取最后一个设置次数的数字即为答案。

29. #### Top K问题

> 输入 n 个整数，找出其中最小的 K 个数。例如输入 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4 。

* 最直观的方法是排序取前k个数字即可。
* 也可以采取快排的思路，每次partition后，判断当前已排序返回的index位置，如果大于k，那么继续在index左边进行partition获取位置；如果小于k，那么在index右边进行partition。这个方法平均时间复杂度为O(n)
* 也可以维护一个容量为k的最大堆，对数组进行遍历，如果堆的大小还没有达到k，则将元素加入最大堆。如果达到了最大堆的大小，先和堆顶（当前堆的最大值）比较，如果比它小，那么替换堆顶，同时调整堆使堆重新有序（这个过程复杂度logK），否则继续遍历数组不更新堆。（js没有内置的堆数据结构，可以用二叉堆进行模拟）

30. #### 最大子序和

> 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。输入[-2,1,-3,4,-1,2,1,-5,4] 它的最大和为6，连续序列为[4,-1,2,1]

https://leetcode-cn.com/problems/maximum-subarray/

可以利用动态规划思想，当对数组中每个数进行相加的时候，可以有两种状态，一种是当前遍历到的数加上上一个数组连续相加的和，另外一种就是不相加，直接取当前遍历到的数字。在这两种状态中取最大的即为当前下标最大和连续子数组。算法复杂度为O(n)

> 相似题目：乘积最大子数组

https://leetcode-cn.com/problems/maximum-product-subarray/
> 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。示例：[2,3,-2,4] 的结果为 6

解法整体的思路还是类似于最大子序号和，将当前数之前已得出的乘积和现在当前遍历的数相乘或不乘取大的那个数字。需要注意的是数字可以取负数，当负数与负数相乘可以使得乘积变大，当负数与正数相乘可以使得乘积变小。因此在保存状态时需要同时保存当前最小的乘积与最大的乘积，并且比较时当前的数字与最小的数字与最大的数字都乘一遍，保存到最小和最大的乘积状态上。

```javascript
dpmax[i] = Math.max(nums[i], nums[i] * dpmin[i - 1], nums[i] * dpmax[i - 1]);
dpmin[i] = Math.min(nums[i], nums[i] * dpmin[i - 1], nums[i] * dpmax[i - 1]);
dp[i] = Math.max(dpmin[i], dpmax[i]); // 两个保存的状态中取大的作为结果
```

31. #### 把数组排成最小的数

> 输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。

https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/

解法为对数组进行排序，但是排序的过程中不是以数字的大小来排序，而是将排序过程中两个相互比较的数字进行拼接后，取拼接结果转换为整型后较小的那个作为排序结果。


32. #### 丑数
> 把只包含质因子 2、3 和 5 的数称作丑数。例如 6、8 都是丑数，但 14 不是，因为它包含因子 7。 习惯上我们把 1 当做是第一个丑数。求
按从小到大的顺序的第 N 个丑数。

https://leetcode-cn.com/problems/ugly-number-ii/

要解决这道题，应该先思考这几个方面：
* 如何生成一个符合要求的丑数序列
* 如何生成一个大到小进行排列的丑数序列（这样才能得到第n个丑数）

第一个问题根据题意，所有的丑数只能由2、3 和 5乘出，所以可以想到通过动态规划，将某一个状态的数字乘以2，3和5就是下一个生成的丑数。
第二个问题：如何生成一个排列的丑数序列，实际上是需要解决上一个问题那个某个状态应该是什么。为了生成从小到大的序列，2，3，5应该是与每个丑数相对应的最小的丑数结果进行相乘：

`在 nums[i2] * 2，nums[i3] * 3 和 nums[i5] * 5 选出最小的数字添加到数组 nums 中。`

34. #### 第一个只出现一次的字符

> 在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。

https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/

主要考察哈希表的使用，将每个字符作为map的key，在遍历每个字符的时候，在map中对应更新每个字符出现的次数，最后遍历一遍Map的entries()，返回次数为1的即可。（JS的map是有序的，所以次数为1一定是第一次出现的字符）（也可以不用计数统计次数，只要map中没出现过设为true，出现过就设置为false，最后返回第一个为true的字符）

35. #### 数组中逆序对

> 在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组，求出这个数组中的逆序对的总数。

https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof/submissions/

统计逆序对可以利用归并排序，在合并的过程统计左半边每个数组元素比右半边数组元素大的数量。如果直接使用两层循环，这个过程的复杂度会达到o(n^2),算法会超时，所以需要优化。


合并方法：
* 5,7 | 4, 6 这两个有序数组中
* 数组二先指向第一个4，数组一先指向第一个元素5
* 由于5比4大，由于是有序的数组，所以后续所有元素都比4大，所以此时能组成2个逆序对
完成判断后将4放入临时结果数组，第二个数组指针下移，判断6和5
* 由于5比6小，不能构成逆序对，所以将5放入临时数组，左边数组指针后移
* 此时7比6大，左边还剩余一个元素，将6放入临时数组
* 此时右边数组全部遍历完毕，将左边所有元素放入临时数组返回，完成一次合并及逆序对统计

具体过程可参考https://juejin.im/post/5b6cfb746fb9a04fae213694

36. #### 两个链表的第一个公共结点数组中逆序对

> 输入两个链表，找出它们的第一个公共结点。

https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/

* 第一个方法可以利用一个栈，从题目上看，两个链表的结尾都是公共节点。利用这个特点，将两个链表进行入栈，随后同时将两个链表进行出栈，出栈的时候比较出栈节点，最后一次相同的节点即为公共节点。

* 如果不用额外空间，还可以将两个链表长度进行相减，再利用两个指针，将较长那个链表先走n步（n为链表相减的长度），随后两个指针同时移动，第一次相等的节点即为公共节点。

37. #### 数字在排序数组中出现的次数

> 统计一个数字：在排序数组中出现的次数。例如输入排序数组｛ 1, 2, 3, 3, 3, 3, 4, 5｝和数字 3 ，由于 3 在这个数组中出
现了 4 次，因此输出 4 。

一种是直接遍历一遍数组统计顺序，由于数组是经过排序的，可以先利用二分法找到目标数字，再前后寻找出现数字的边界并进行数量统计。这样可以达到对数复杂度。

38. #### 二叉树的深度

> 输入一棵二叉树，求该树的深度。从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深
度。

用DFS遍历树，并统计经过的节点数量，统计数量即可。

39. #### 平衡二叉树

> 输入一棵二叉树，判断该二叉树是否是平衡二叉树。

根据平衡二叉树的定义，二叉树左右两个分支的高度差不超过1，可以利用递归分别计算二叉树两边高度，如果高度超过1，直接向上返回-1表明不是一个平衡二叉树。

40. #### 数组中只出现一次的数字

> 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

除了遍历一遍数组记录次数外，最快的方法还是利用异或运算。如果只是求出一个数字，进行一遍异或运算即可。但是这道题有两个数字只出现一次，异或的结果是这两个出现一次数字的异或结果，所以要想办法拆出这个数字。由于一定是两个不同的数字，所以他们必然有一位（bit）是不同的。先找出那个不同的一位，随后根据这个不同的一位，将所有数字分类成有这一位和没有这一位的数组，再将他们进行一遍异或运算，两个数组留下的那个数字即为只出现一次的两个数字。参考了https://zhuanlan.zhihu.com/p/104143304

