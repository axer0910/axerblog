---
title: 剑指Offer 66道算法题整理
tag: 刷题
date: 2020-06-03
updated: 2020-06-03
---

1.  #### 二维数组中的查找
https://leetcode.com/problems/search-a-2d-matrix-ii/

* 思路：一定要从右上角开始进行查找，根据题意矩阵的横向和纵向都是递增序列，如果从矩阵左上角位置开始查找，不容易对需要进行搜索的数确定范围（横向纵向都是递增序列），从右上角搜索的话，向左是递减，向下是递增，这样只需要目标数比当前数大就向下搜索，目标数比当前数小就向左搜索（类似于二分，不断缩小范围）。

2. #### 替换空格
  > 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20
Are%20Happy

* 正则替换就ok了（str.replace('/\s/g', '%20')）或者for循环遍历直接替换空格

3. #### 逆序输出链表：
* 输出链表每个节点的值：从头节点遍历链表，push到一个临时数组，完成遍历后再一个个从数组中pop值即可。
* 反转链表：https://leetcode.com/problems/reverse-linked-list/
迭代法思路：
```javascript
var reverseList = function(head) {
  if (!head || !head.next) return head;
  let newHead = null; // newHead在每次迭代中都指向head，同时更新next，最后实现翻转
  while (head) {
    const temp = head; // 临时保存头节点信息
    head = head.next; // 头指针指向先下一个节点
    temp.next = newHead; // 翻转后的节点，在第一轮temp此时是作为反转后链表的最后一个节点（next指向null）
    newHead = temp; // 在第一轮更新的newHead指向最后一个节点，后续newHead不断向前指向头节点
  }
  return newHead;
};
```
4. #### 重建二叉树
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

* 思路：前序遍历中，每一个节点都对应的是二叉树根节点。在中序遍历中，所有节点都是以左-根-右的顺序进行遍历。根据这个特性，先确定前序遍历中每个元素在后序遍历中的位置，确定了在后序遍历中的位置以后，所有在后序遍历中左边部分是重建后二叉树的左子树，右边部分是右子树。所以只需要用一个函数，接受两个后序遍历左右位置的参数，确定每次构建二叉树寻找的范围。找到根节点位置后将此位置作为中枢分别对左半部分和右半部分递归进行构建二叉树即可。

5. #### 用两个栈实现队列
 https://leetcode.com/problems/implement-queue-using-stacks/submissions/

思路：题目要求用两个栈来实现队列操作。思路是添加队列内容时在第一个栈里进行push，当需要取队列内容的时候，将队列所有内容pop到第二个栈（栈先进后出的特点，pop到第二个栈所有元素顺序正好变成先进先出），再进行pop即可取出一个队列内容。

6. #### 旋转数组的最小数字
> 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的
最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大
小为 0，请返回 0。

思路：

（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相
邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。

（2）二分法

leetcode没找到对应的题目，暂时先记录一下思路

7. #### 斐波那契数列
输入斐波那契数列第n项返回斐波那契数列总和。求和的过程就是斐波那契数列当前n项的和 =（n-1）项的和加上（n-2）项和。用递归即可。不用递归的话，用两个变量分别记录n-1的和和n-2的和，每次轮询进行相加。

https://leetcode.com/problems/fibonacci-number/

8. #### 跳台阶
9. #### 变态跳台阶

https://leetcode.com/problems/climbing-stairs/ 
解法是动态规划，关键思路是要得出当前台阶数n所对应的方法数量，由于一次可以跳一个台阶或者两个台阶，所以当前台阶数n对应的方法数量 = n-1个台阶的方法数加上n -2个台阶方法数。（这个推导过程可以理解为n-1对应的所有方法中每个方法都可以再跳一层达到当前状态，n-2同理），变态跳台阶（可以一次跳n个台阶）公式则变为n = (n - 1) + (n - 2) + ... + (n - n)。
关键思路：获取当前状态怎么由上一个状态+能达到这个状态的关系

10. #### 矩形覆盖
> 我们可以用2 * 1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2 * 1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

思路：也是斐波那契数列（动态规划）的应用。当只有一个2 * 1的矩形，只有一种方法，即使用2 * 1的矩形去覆盖，当有一个2 * 2的矩形，可以用两个2*1的矩形横向覆盖也可以纵向覆盖，所以有两种方法。当有一个2 * 3的矩形，可以有（形成2 * 2组成矩形的方法+用一个矩形去覆盖）的数量+（形成2 * 1组成矩形的方法+用一个矩形去覆盖）的数量。 所以推导关系就是`f(n-1)+f(n-2)`。

11. #### 二进制中 1 的个数
> 题目：输入一个整数，输出该数二进制表示中 1 的个数。其中负数用补码表示。
> 举例：二进制00000000000000000000000000001011中，共有3个1，11111111111111111111111111111101中有31个1

https://leetcode.com/problems/number-of-1-bits/

一个不为0的二进制数，一定在最右边存在以为1，拿1100为例子，为了取得二进制中1的个数，可以先减掉1，1100就变成了1011，这样除了最高位其余位数都退了1位。利用这个特点将减1后的数字和没减之前的数字进行与运算，1100&1011=1000。如果与运算结果不为1，那意味着最高位还存在1。此时再讲1011减1，重复与运算的过程，只要最后与运算结果不为0，数量就递增，最后就可以统计出1的个数。

12. #### 数值的整数次方
> 题目：给定一个 double 类型的浮点数 base 和 int 类型的整数 exponent。求 base 的 exponent 次方。 

https://leetcode.com/problems/powx-n/

最直接的办法就是写个循环指数是多少base就乘以几次，但是在这道题中指数最大可以取到32位有符号整数。这意味着当指数很大的时候直接相乘会超时，必须想办法节省时间。分析直接实现pow的过程可以发现，2^3次方就是2 * 2 * 2 乘以三次，当2^4次方的时候，就是2 * 2 * 2 * 2，如果指数是2的倍数，只需要乘以指数/2次，将折半后的结果再相乘，这样时间就可以少一半。

比较简洁的递归代码
```javascript
var myPow = function(x, n) {
  if (n == 0) return 1;
  let half = myPow(x, parseInt(n / 2));
  if (n % 2 == 0) return half * half;
  if (n > 0) return half * half * x;
  return half * half / x;
};
```
* 每次递归时，指数取余，如果余数是0（2的倍数），将折半的结果相乘
* 如果不是2的倍数，在折半相乘的基础上再乘以一个基数x
* 如果n小于0，在折半相乘的基础上除以x（如果输入是2^-1，那么return就是1 * 1 / 2 即 0.5），其他的负数重复一样的递归过程（指数取余是0直接折半相乘，不除以x）

13. #### 调整数组顺序使奇数位于偶数前面

> 题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。

https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/

解法：使用两个指针，左指针指向偶数元素，右指针指向奇数元素。当不满足这个条件的时候，两个指正分别向后和向前移动，直到满足条件时两个指针上的元素进行互换。这样的好处是不用额外空间。但是如果题目要求奇数和奇数，偶数和偶数之间的相对位置不变时，就不能用这个方法了。为了保持顺序的稳定，可以另外建立两个个辅助数组，分别存放偶数元素和奇数元素，最后将辅助数组进行拼接返回即可。时间和空间复杂度均为O(n)。

14. #### 链表中倒数第 k 个节点
> 输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。

https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/

解法：遇到这种链表符合某种条件的第k个节点问题，可以考虑将链表进行一些相减的操作。这道题要求出倒数第k个节点，可以用两个节点，先让一个结点先走k-1步，这样与另外一个节点获取了和倒数第k个节点一样的距离差，此时两个节点同时向后移动，当后面一个节点指向最后一个节点时，前面的一个节点即为倒数第k个节点。

15. #### 反转链表

做第三题的时候把反转链表也写了下，见第三题思路。

16. #### 合并两个排序的链表

> 题目：输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。

解法：由于是单调递增的两个链表，建立两个指针分别指向两个链表，首先取较小元素作为头结点，然后当两个指针都没有指向末尾的时候，哪个指正对应的指小取哪个，然后链表指针向下。当然也可以用递归的方法实现。

17. #### 树的子结构

> 输入两棵二叉树 A、B，判断 B 是不是 A 的子结构。（ps：我们约定空树不是任意一个树的子结构）

解法：如果B是A的子结构，必然在A中间包含B的根节点，先用DFS的方法递归遍历A树找到与B根节点相同的元素，再讲两个树按照相同的方法继续遍历，判断是不是相同。

18. #### 二叉树的镜像
> 操作给定的二叉树，将其变换为源二叉树的镜像。

解法：递归的解法只需要将当前节点的左右节点互换即可。如果不用递归，可以实现层次遍历，先将左右节点入队，再出队左节点，交换他的子节点，并将子节点入队（如果不为null）。当队列不为空时，重复这个过程即可完成。也可以使用先序遍历，建立一个栈，将根节点入栈，当栈不为空时进行出栈操作，并且交换出栈元素的子节点。当子节点不为null时，再进行入栈，之后一样的出栈操作就可以完成交换。

19. #### 顺时针打印矩阵

https://leetcode.com/problems/spiral-matrix/

> 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字，
例如，如果输入如下矩阵： 
1 2 3 4
5 6 7 8
9 10 11 12
13 14 15 16
则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10

解法：顺时针打印矩阵的时候，他的范围一定是限制在左上顶点和右下顶点之中。确定了左上顶点和右下顶点，就可以通过for循环依次将四条边打印出来。然后两个顶点两个坐标分别-1和+1向中心推进，再按顺序打印值即可。需要注意的是，如果两个点在矩阵同一行或同一列上面，则需要直接返回，不然会重复输出同一行或同一列矩阵元素。

20. #### 定义一个栈，实现 min 函数
> 定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的 min 函数。

https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof/

解法：建立两个栈，一个存储元素，一个辅助最小元素栈，当当前入栈的元素比最小元素的栈顶元素还要小时，在最小元素栈入栈一个最小元素。取最小元素就取最小元素辅助栈的栈顶。当出栈元素的时候，如果最小元素栈的栈顶为当前出栈元素则一同出栈。取最小值只需要取辅助栈栈顶即可。

21. #### 栈的压入弹出

> 输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如
序列 1,2,3,4,5 是某栈的压入顺序，序列 4,5,3,2,1 是该压栈序列对应的一个弹出序列，但 4,3,5,1,2 就不可能是该压栈序
列的弹出序列。（注意：这两个序列的长度是相等的）

根据栈的先进后出特点，如果1,2,3,4,5全部按照顺序进行入栈，那么出栈的顺序为5,4,3,2,1。入一个再出一个为1,2,3,4,5
根据这个特点，先将测试的序列与正常出栈的序列进行对比，如果当前指针两边的数字不一样，则跳过继续，否则将元素推入一个辅助栈当中。完成之后先将辅助栈出栈与原栈顺序对比，再将剩余的元素按倒序和原栈顺序对比是否一致。

22. #### 从上往下打印二叉树

> 从上往下打印出二叉树的每个节点，同层节点从左至右打印。

解法：就是层次遍历，先建立一个队列，将根节点入队，随后出队根节点，再加根节点的左右子节点入队。当队列长度不为0重复这个过程。