---
title: 剑指Offer 66道算法题整理
tag: 刷题
date: 2020-06-03
updated: 2020-06-03
---

1.  #### 二维数组中的查找
https://leetcode.com/problems/search-a-2d-matrix-ii/

* 思路：一定要从右上角开始进行查找，根据题意矩阵的横向和纵向都是递增序列，如果从矩阵左上角位置开始查找，不容易对需要进行搜索的数确定范围（横向纵向都是递增序列），从右上角搜索的话，向左是递减，向下是递增，这样只需要目标数比当前数大就向下搜索，目标数比当前数小就向左搜索（类似于二分，不断缩小范围）。

2. #### 替换空格
  > 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为 We Are Happy.则经过替换之后的字符串为 We%20
Are%20Happy

* 正则替换就ok了（str.replace('/\s/g', '%20')）或者for循环遍历直接替换空格

3. #### 逆序输出链表：
* 输出链表每个节点的值：从头节点遍历链表，push到一个临时数组，完成遍历后再一个个从数组中pop值即可。
* 反转链表：https://leetcode.com/problems/reverse-linked-list/
迭代法思路：
```
var reverseList = function(head) {
  if (!head || !head.next) return head;
  let newHead = null; // newHead在每次迭代中都指向head，同时更新next，最后实现翻转
  while (head) {
    const temp = head; // 临时保存头节点信息
    head = head.next; // 头指针指向先下一个节点
    temp.next = newHead; // 翻转后的节点，在第一轮temp此时是作为反转后链表的最后一个节点（next指向null）
    newHead = temp; // 在第一轮更新的newHead指向最后一个节点，后续newHead不断向前指向头节点
  }
  return newHead;
};
```
4. #### 重建二叉树
https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

* 思路：前序遍历中，每一个节点都对应的是二叉树根节点。在中序遍历中，所有节点都是以左-根-右的顺序进行遍历。根据这个特性，先确定前序遍历中每个元素在后序遍历中的位置，确定了在后序遍历中的位置以后，所有在后序遍历中左边部分是重建后二叉树的左子树，右边部分是右子树。所以只需要用一个函数，接受两个后序遍历左右位置的参数，确定每次构建二叉树寻找的范围。找到根节点位置后将此位置作为中枢分别对左半部分和右半部分递归进行构建二叉树即可。

5. #### 用两个栈实现队列
 https://leetcode.com/problems/implement-queue-using-stacks/submissions/

思路：题目要求用两个栈来实现队列操作。思路是添加队列内容时在第一个栈里进行push，当需要取队列内容的时候，将队列所有内容pop到第二个栈（栈先进后出的特点，pop到第二个栈所有元素顺序正好变成先进先出），再进行pop即可取出一个队列内容。

6. #### 旋转数组的最小数字
> 题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的
最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为 1。 NOTE：给出的所有元素都大于 0，若数组大
小为 0，请返回 0。

思路：

（1）我们输入的是一个非递减排序的数组的一个旋转，因此原始数组的值递增或者有重复。旋转之后原始数组的值一定和一个值相
邻，并且不满足递增关系。因此我们就可以进行遍历，找到不满足递增关系的一对值，后一个值就是旋转数组的最小数字。

（2）二分法

leetcode没找到对应的题目，暂时先记录一下思路

7. #### 斐波那契数列
输入斐波那契数列第n项返回斐波那契数列总和。求和的过程就是斐波那契数列当前n项的和 =（n-1）项的和加上（n-2）项和。用递归即可。不用递归的话，用两个变量分别记录n-1的和和n-2的和，每次轮询进行相加。

https://leetcode.com/problems/fibonacci-number/

8. #### 跳台阶
9. #### 变态跳台阶

https://leetcode.com/problems/climbing-stairs/ 
解法是动态规划，关键思路是要得出当前台阶数n所对应的方法数量，由于一次可以跳一个台阶或者两个台阶，所以当前台阶数n对应的方法数量 = n-1个台阶的方法数加上n -2个台阶方法数。（这个推导过程可以理解为n-1对应的所有方法中每个方法都可以再跳一层达到当前状态，n-2同理），变态跳台阶（可以一次跳n个台阶）公式则变为n = (n - 1) + (n - 2) + ... + (n - n)。
关键思路：获取当前状态怎么由上一个状态+能达到这个状态的关系

10. #### 矩形覆盖
> 我们可以用2*1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2*1的小矩形无重叠地覆盖一个2*n的大矩形，总共有多少种方法？

思路：当只有一个2*1的矩形，只有一种方法使用2*1的矩形去覆盖，当有一个2*2的矩形，可以用两个2*1的矩形横向覆盖也可以纵向覆盖，所以有两种方法。当有一个2*3的矩形，可以有（2*2的组成矩形的方法数量+用一个矩形覆盖）的数量+（2*1的组成矩形的方法数量+用两个矩形覆盖）的数量。 所以推导关系就是`f(n-1)+f(n-2)`。